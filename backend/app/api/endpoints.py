from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import Any, List, Dict, Optional
from app.agent.graph import app as agent_app
from app.services.finance import get_stock_history
from app.services.cache import CacheService
from app import schemas, models
from app.db import get_db
from app.auth_utils import get_current_user
from app.services.gemini_resolver import resolve_gemini_key

router = APIRouter()

# --- Request Models ---
class QueryRequest(BaseModel):
    query: str

class AnalysisResponse(BaseModel):
    id: Optional[int] = None
    company_name: str
    report_content: str
    chart_data: Optional[Dict[str, Any]] = None

# --- Helpers ---
def parse_agent_response(content: Any) -> str:
    if isinstance(content, str): return content
    if isinstance(content, list):
        text_parts = []
        for block in content:
            if isinstance(block, dict) and block.get("type") == "text":
                text_parts.append(block.get("text", ""))
            elif hasattr(block, "text"):
                text_parts.append(block.text)
        return "\n".join(text_parts)
    return str(content)

# --- Endpoints ---

@router.post("/analyze", response_model=AnalysisResponse)
async def analyze_company(
    request: QueryRequest, 
    db: Session = Depends(get_db),
    current_user: models.User = Depends(get_current_user)
):
    try:
        query_key = request.query.strip().upper()
        cache_key = f"report:{query_key}"

        # 1. CHECK CACHE (Fast Path)
        cached_data = CacheService.get(cache_key)
        if cached_data:
            print(f"âš¡ CACHE HIT: {query_key}")
            return cached_data

        print(f"ðŸ¢ CACHE MISS: {query_key} -> Running Agent...")

        # 1.5. Check User API Key
        api_key = resolve_gemini_key(current_user)
        if not api_key:
            raise HTTPException(status_code=428, detail="Bring Your Own Key (BYOK) required.")

        # 2. RUN AGENT (Slow Path)
        initial_state = {"messages": [("user", request.query)], "api_key": api_key}
        result = await agent_app.ainvoke(initial_state)
        raw_content = result["messages"][-1].content
        report_text = parse_agent_response(raw_content)
        
        # 3. FETCH VISUALS
        try:
            chart_data = get_stock_history(request.query)
        except Exception:
            chart_data = None

        # 4. SAVE TO DATABASE (Persistent Memory)
        db_report = models.Report(
            company_name=query_key,
            report_content=report_text,
            chart_data=chart_data,
            owner_id=current_user.id
        )
        db.add(db_report)
        db.commit()
        db.refresh(db_report)

        # 5. CONSTRUCT RESPONSE
        response_data = {
            "id": db_report.id,
            "company_name": query_key,
            "report_content": report_text,
            "chart_data": chart_data
        }

        # 6. SAVE TO CACHE (12 Hour TTL)
        CacheService.set(cache_key, response_data, expire_seconds=43200)

        return response_data

    except HTTPException as http_exc:
        # Re-raise the HTTP exception specifically so the 428 bypasses the generic catch
        raise http_exc
    except Exception as e:
        error_str = str(e).lower()
        print(f"Error in analysis: {error_str}")
        
        # Check for invalid key, quota exhaustion, or other generative AI auth errors
        if any(keyword in error_str for keyword in [
            "api key not valid", "api_key_invalid", "quota", "429", "exhausted", "403", "401"
        ]):
            # The saved key was invalid or exhausted. Delete it so the user is prompted again.
            from app.services.supabase_client import delete_user_gemini_key
            if hasattr(current_user, "supabase_uid") and current_user.supabase_uid:
                delete_user_gemini_key(current_user.supabase_uid)
            raise HTTPException(status_code=428, detail="Key invalid or exhausted. Please provide a new API key.")
            
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/reports", response_model=List[schemas.ReportResponse])
def get_user_reports(
    db: Session = Depends(get_db),
    current_user: models.User = Depends(get_current_user)
):
    """Fetch all reports generated by the logged-in user."""
    return db.query(models.Report).filter(models.Report.owner_id == current_user.id).order_by(models.Report.created_at.desc()).all()

@router.delete("/reports/{report_id}")
def delete_report(
    report_id: int,
    db: Session = Depends(get_db),
    current_user: models.User = Depends(get_current_user)
):
    """Delete a specific report."""
    report = db.query(models.Report).filter(models.Report.id == report_id, models.Report.owner_id == current_user.id).first()
    if not report:
        raise HTTPException(status_code=404, detail="Report not found")
    
    db.delete(report)
    db.commit()
    return {"status": "deleted", "id": report_id}

@router.get("/reports/{report_id}", response_model=schemas.ReportResponse)
def get_report(
    report_id: int,
    db: Session = Depends(get_db),
    current_user: models.User = Depends(get_current_user)
):
    """Fetch a single report by ID."""
    report = db.query(models.Report).filter(
        models.Report.id == report_id, 
        models.Report.owner_id == current_user.id
    ).first()
    
    if not report:
        raise HTTPException(status_code=404, detail="Report not found")
        
    return report